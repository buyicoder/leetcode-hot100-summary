# 力扣hot100扫题

## 规则

看一眼题目，快速简短地说出不同方法的思路

## 题目

## ==哈希==

### 两数之和

哈希表

### 字母异位词分组

哈希表记录每一种字母异位词的集合编号

遍历字符串数组，用排序后的字符串作为键判断是否在哈希表中，如果不在 ，分配新的编号，加入哈希表，将包含此字符串的集合加入结果列表，如果在，将该字符串加入对应集合

### 最长连续列表

遍历哈希表

将所有数组元素加入哈希表。

遍历哈希表，若当前元素x-1在哈希表中，跳过，否则，不停判断x+1是否在哈希表中，直到不在，然后更新最长长度

## ==双指针==

### 移动零

遍历时使用cnt统计当前遇到的0的个数

i表示0区间的起点（cnt为0时区间为空）

，【i，i+cnt）表示0区间，i+cnt是0区间之后的第一个非0元素，需要与i元素交换。当然需要保证i+cnt不越界才能交换，越界了直接结束。

### 盛水最多的容器

双指针从两边向中间靠拢，每次移动更矮的那个指针，每次用宽度乘高度得到当前盛水量，用于更新最大盛水量

### 三数之和

哈希表+双指针

### 接雨水

- 计算每个位置的左右最大值之后得到每个位置的雨水，之后相加
- 单调栈每次求出以当前高度作为右边界的雨水，保证该区间内雨水不重复。

## ==滑动窗口==

### 无重复字符的最长子串

滑动窗口+哈希表记录当前子串每个字符的位置

记得更新左指针的时候也要更新哈希表，取出左指针扫过的字符

### 找到字符串中所有字母异位词

固定长度滑动窗口扫过字符串，判断每个窗口是否是异位词，判断异位词可以用计数法判断。

### 和为K的子数组

- 前缀和+哈希表优化

### 滑动窗口最大值

使用优先队列

先将前K个元素加入优先队列。

从第k+1个元素开始遍历。将堆顶元素取出，判断堆顶元素是否在滑动窗口内，如果是，作为最大值加入结果列表，如果不是，取出下一个堆顶元素。然后将当前元素加入优先队列。

这里注意优先队列需要存每个元素的下标用于判断该元素是否在窗口内。

### 最小覆盖子串

- 首先左右指针都为0。表示空字符串。

- 当左右指针不互串不越界时循环
  - 右指针右移动，直到区间覆盖t中所有字符
  - 左指针右移，同时尝试更新最小子串，直到首次不覆盖t中所有字符
- 注：使用计数法判断是否覆盖t中所有字符。

### 最大子数组和

- 前缀和+求左右最大值

### 合并区间

- 所有区间按照起点大小排序

- 用start，end表示待合并区间
- 遍历区间集合
  - 若当前区间起点小于待合并区间终点，可将二者合并成为新的待合并区间
  - 若当前区间起点大于待合并区间终点，待合并区间无法继续合并，加入到结果列表，当前区间成为新的待合并区间

### 轮转数组

翻转三次

### 除自身以外数组的乘积

- 求出每个元素左乘积和右乘积

### 缺失的第一个正数

- 哈希表
- 将数组恢复成佯有序数组

### 矩阵置零

遍历一遍，记录有0的行和列

### 螺旋矩阵

模拟

### 旋转图像

- 模拟
- 主对角线翻转+左右翻转

### 搜索二维矩阵II

从右上角开始搜，当成二叉搜索树，往左就是左子树，往下就是右子树

## ==链表==

### 相交链表

两个指针分别从A和B开始同步遍历，A开始的指针到末尾了从B开始，B开始的指针到末尾了从A开始，每一步都判断两个指针是否相遇，m+n步之后，最终会在交叉处相遇。

### 反转链表

- 递归，翻转next，next的next为curr，curr的next为空。
- 或者三指针穿针引线，prev，curr，next

### 回文链表

翻转之后判断是否相等，

或者反转后半部分判断是否和前半部分相等，然后再反转回来

### 环形链表

快慢指针，看是先相遇还是先到末尾

### 环形链表II

快慢指针，相遇后慢指针回到头节点，同步走，最终快慢指针在交叉口相遇

### 合并两个有序链表

略，唯手熟尔

### 两数相加

和数组版本没区别

### 删除链表的倒数第N个结点

前后指针

### 两两交换链表中的节点

递归

### K个一组翻转链表

找到待翻转的链表，提取出来后翻转，然后迭代翻转下一个部分

### 随机链表的复制

- 哈希表法
- 复制后拆分

### 排序链表

自底向上的归并排序

### 合并K个升序链表

使用优先队列，将所有链表的头节点加入优先队列，然后取出每次堆顶元素加入到当前链表末尾，将堆顶元素的下一个节点加入优先队列。

### LRU缓存

写一个双向链表

取出remove操作将节点从链表中取出，insert操作将节点从链表中插入，哈希表记录键值对，更新节点操作将节点放到链表开头。

get，用哈希表判断是否有该元素，有则取出，没有则返回-1。

put，用哈希表判断是否有该元素，有则直接修改值，同时更新节点，没有则创建新的结点，插入到链表当中，如果链表长度超过限制，将链表尾的元素取出，同时将该元素对应的键从哈希表中删除，最后释放内存。

### ==二叉树==

### 二叉树的中序遍历

- 递归法
- 迭代法
  - 进入大循环，条件是root不为空或者栈不为空
    - 进入小循环，条件是root不为空
      - 将root入栈
      - root进入左子树
    - root成为栈顶元素
    - 访问root的值
    - root进入右子树

### 二叉树的最大深度

- 递归，返回左右子树最大深度的更大值+1

### 翻转二叉树

- 递归翻转左子树和右子树
- 交换左子树和右子树

### ==对称二叉树==

​	使用辅助函数进行递归

### 二叉树的直径

维护两个值：直径，最大深度

根直径=max（左最大深度，右最大深度）+1；

直径=max（左直径，右直径，左最大深度+1+右最大深度）；

### 二叉树的层序遍历

队列

### ==将有序数组转换为二叉搜索树==

递归，使用辅助函数递归

### ==验证二叉搜索树==

迭代中序遍历，判断curr是否递增

### ==二叉搜索树中第K小的元素==

迭代中序遍历

### ==二叉树的右视图==

层序遍历

### 

