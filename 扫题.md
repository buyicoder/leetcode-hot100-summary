# 力扣hot100扫题

## 规则

看一眼题目，快速简短地说出不同方法的思路

## 题目

## ==哈希==

### ==两数之和==

哈希表

先查找哈希表中是否存在目标元素，然后再将当前元素插入哈希表

### 字母异位词分组

哈希表记录每一种字母异位词的集合编号

遍历字符串数组，用排序后的字符串作为键判断是否在哈希表中，如果不在 ，分配新的编号，加入哈希表，将包含此字符串的集合加入结果列表，如果在，将该字符串加入对应集合

### 最长连续列表

遍历哈希表

将所有数组元素加入哈希表。

遍历哈希表，若当前元素x-1在哈希表中，跳过，否则，不停判断x+1是否在哈希表中，直到不在，然后更新最长长度

## ==双指针==

### 移动零

遍历时使用cnt统计当前遇到的0的个数

i表示0区间的起点（cnt为0时区间为空）

，【i，i+cnt）表示0区间，i+cnt是0区间之后的第一个非0元素，需要与i元素交换。当然需要保证i+cnt不越界才能交换，越界了直接结束。

### 盛水最多的容器

双指针从两边向中间靠拢，每次移动更矮的那个指针，每次用宽度乘高度得到当前盛水量，用于更新最大盛水量

### ==三数之和==

排序+双指针

数不能重复使用：

先排序

每一层循环从上一层循环的下一个数开始

组合不能重复：

每一层循环内的数不能重复

第三重循环使用右指针向左移动即可，可以降低复杂度。

### 接雨水

- 计算每个位置的左右最大值之后得到每个位置的雨水，之后相加
- 单调栈每次求出以当前高度作为右边界的雨水，保证该区间内雨水不重复。

## ==滑动窗口==

### 无重复字符的最长子串

滑动窗口+哈希表记录当前子串每个字符的位置

记得更新左指针的时候也要更新哈希表，取出左指针扫过的字符

### 找到字符串中所有字母异位词

固定长度滑动窗口扫过字符串，判断每个窗口是否是异位词，判断异位词可以用计数法判断。

### 和为K的子数组

- 前缀和+哈希表优化

### 滑动窗口最大值

使用优先队列

先将前K个元素加入优先队列。

从第k+1个元素开始遍历。将堆顶元素取出，判断堆顶元素是否在滑动窗口内，如果是，作为最大值加入结果列表，如果不是，取出下一个堆顶元素。然后将当前元素加入优先队列。

这里注意优先队列需要存每个元素的下标用于判断该元素是否在窗口内。

### 最小覆盖子串

- 首先左右指针都为0。表示空字符串。

- 当左右指针不互串不越界时循环
  - 右指针右移动，直到区间覆盖t中所有字符
  - 左指针右移，同时尝试更新最小子串，直到首次不覆盖t中所有字符
- 注：使用计数法判断是否覆盖t中所有字符。

### 最大子数组和

- 前缀和+求左右最大值

### 合并区间

- 所有区间按照起点大小排序

- 用start，end表示待合并区间
- 遍历区间集合
  - 若当前区间起点小于待合并区间终点，可将二者合并成为新的待合并区间
  - 若当前区间起点大于待合并区间终点，待合并区间无法继续合并，加入到结果列表，当前区间成为新的待合并区间

### 轮转数组

翻转三次

### 除自身以外数组的乘积

- 求出每个元素左乘积和右乘积

### 缺失的第一个正数

- 哈希表
- 将数组恢复成佯有序数组

### 矩阵置零

遍历一遍，记录有0的行和列

### 螺旋矩阵

模拟

### 旋转图像

- 模拟
- 主对角线翻转+左右翻转

### 搜索二维矩阵II

从右上角开始搜，当成二叉搜索树，往左就是左子树，往下就是右子树

## ==链表==

### 相交链表

两个指针分别从A和B开始同步遍历，A开始的指针到末尾了从B开始，B开始的指针到末尾了从A开始，每一步都判断两个指针是否相遇，m+n步之后，最终会在交叉处相遇。

### 反转链表

- 递归，翻转next，next的next为curr，curr的next为空。
- 或者三指针穿针引线，prev，curr，next

### 回文链表

翻转之后判断是否相等，

或者反转后半部分判断是否和前半部分相等，然后再反转回来

### 环形链表

快慢指针，看是先相遇还是先到末尾

### 环形链表II

快慢指针，相遇后慢指针回到头节点，同步走，最终快慢指针在交叉口相遇

### 合并两个有序链表

略，唯手熟尔

### 两数相加

和数组版本没区别

### 删除链表的倒数第N个结点

前后指针

### 两两交换链表中的节点

递归

### K个一组翻转链表

找到待翻转的链表，提取出来后翻转，然后迭代翻转下一个部分

### 随机链表的复制

- 哈希表法
- 复制后拆分

### 排序链表

自底向上的归并排序

### 合并K个升序链表

使用优先队列，将所有链表的头节点加入优先队列，然后取出每次堆顶元素加入到当前链表末尾，将堆顶元素的下一个节点加入优先队列。

### LRU缓存

写一个双向链表

取出remove操作将节点从链表中取出，insert操作将节点从链表中插入，哈希表记录键值对，更新节点操作将节点放到链表开头。

get，用哈希表判断是否有该元素，有则取出，没有则返回-1。

put，用哈希表判断是否有该元素，有则直接修改值，同时更新节点，没有则创建新的结点，插入到链表当中，如果链表长度超过限制，将链表尾的元素取出，同时将该元素对应的键从哈希表中删除，最后释放内存。

### ==二叉树==

### 二叉树的中序遍历

- 递归法
- 迭代法
  - 进入大循环，条件是root不为空或者栈不为空
    - 进入小循环，条件是root不为空
      - 将root入栈
      - root进入左子树
    - root成为栈顶元素
    - 访问root的值
    - root进入右子树

### 二叉树的最大深度

- 递归，返回左右子树最大深度的更大值+1

### 翻转二叉树

- 递归翻转左子树和右子树
- 交换左子树和右子树

### ==对称二叉树==

​	使用辅助函数进行递归

### 二叉树的直径

维护两个值：直径，最大深度

根直径=max（左最大深度，右最大深度）+1；

直径=max（左直径，右直径，左最大深度+1+右最大深度）；

### 二叉树的层序遍历

队列

### ==将有序数组转换为二叉搜索树==

递归，使用辅助函数递归

### ==验证二叉搜索树==

迭代中序遍历，判断curr是否递增

### ==二叉搜索树中第K小的元素==

迭代中序遍历

### ==二叉树的右视图==

层序遍历

### ==二叉树展开为链表==

- 前序遍历
- 寻找前驱节点（空间复杂度为1，时间复杂度为n方）
  - 左子树中最后一个节点被访问之后，访问右子树的节点。

### ==从前序与中序遍历序列构造二叉树==

- 递归
  - 将辅助函数增加表示数组范围的参数
- 迭代
  - 慢慢写吧就

### ==路径总和III==

使用哈希表记录从root到目前这个节点为止某个路径和的路径数目，使用深搜遍历一遍树。

### ==二叉树的最近公共祖先==

- 如果root是空或就是p或q，直接返回

- 在左子树中找p或q
- 在右子树中找p或q
- 左右都找到，当前root就是最近公共祖先
- 只找到一个，吧那个往上返回

### ==二叉树中的最大路径和==

- 求出每个节点的贡献值，即经过每个节点的最大路径和，然后维护最大的路径和

- 只有在最大贡献值大于0时，才会选取对应子节点
- 节点的最大路径和取决于该节点的值与该节点的左右节点的最大贡献值
- 更新答案
- 返回节点的最大贡献值

### ==岛屿数量==

本质是求图的连通分量数

对图dfs，遍历过的点做好标记，每次开一个深搜计数就+1

### ==腐烂的橘子==

多源广度优先搜索

### 课程表

有向环检测

dfs，onStack记录某个顶点是否在栈上

### 前缀树

记得用isEnd判断是否是末尾字符

### 全排列

dfs

### 子集

dfs

### 电话号码的字母组合

dfs

### 组合总和

dfs

### 括号生成

分别记录当前左右括号的数目，只要保证每次左括号数大于右括号数并且左右括号数都小于N就可以了。

### 单词搜索

dfs

### ==分割回文串==

dfs+动态规划

### N皇后

使用三个数组来记录棋盘的每个位置是否可以占用

## 二分查找

代码模板

```C++
int binarySearch(vector<int> & nums,int target, bool findLeft){
    int left = 0;
    int right = nums.size();
    while(left<right){
        int mid = left+(right - left)/2;
        if(findLeft){
            if(nums[mid]<target)left = mid+1;
            else right = mid;
        }
        else{
            if(nums[mid]<=target)left = mid+1;
            else right = mid;
        }
    }
    return left;
}
```

### 搜索插入位置

### 搜索二维矩阵

和一维的没区别

### 在排序数组中查找元素的第一个和最后一个位置

进阶二分查找模板

### 搜索旋转排序数组

旋转排序数组，二分后必然有一个区间是有序的，只需要比较区间的第一个数和最后一个数的大小就可以知道该区间是否有序。

### 寻找旋转排序数组中的最小值

以最后一个数作为基准，二分查找，小于最后一个数则向左移动，大于最后一个数则向右移动。

### 寻找两个正序数组的中位数

寻找两个正序数组的第k大的数：

比较两个数组的第k/2个数，更小的那个数组可以排除掉k/2个数，找剩下的数的第k/2大的数，问题的规模每次减小一半。

### 有效的括号

使用栈，每次遇到左括号就入栈，遇到右括号就尝试匹配栈顶括号，匹配成功则删除，匹配失败说明括号无效，最后栈为空则说明括号有效。

### 最小栈

使用辅助栈记录每一层的最小元素

### 字符串解码

用栈

### 每日温度

单调栈

### 柱状图中最大的矩形

得到每个位置的第一个左边小于和右边小于的位置，遍历求出最大矩形

## ==堆==

### 数组中的第K个最大元素

使用K大小的小顶堆

或者将整个数组构造成大顶堆，然后依次排序

### 前K个高频元素

哈希表计数，然后按照出现次数排序

### 数据流的中位数

- 维护两个优先队列
- 双指针

## 贪心

### 买卖股票的最佳时机

维护当前已遍历数中的最小值，每次将当前值减去最小值，同时维护买卖股票最大值。

### 跳跃游戏

逐个元素遍历，同时维护当前能到达的最远下标

### 跳跃游戏II

逐个元素遍历，维护cnt，end和next，cnt为到达当前下表需要的最小步数，end存储当前这一步能到达的最远下标，next存储，下一步能到达的最远下表，直到最后n-1，返回cnt

### 划分字母区间

哈希表记录每个字母出现的最大下标，

遍历字符串，维护当前片段的最早结束下标end，当遍历到end的时候，将该片段长度加入结果列表，开始新的片段的维护。

## 动态规划

### 爬楼梯

使用ppre和pre维护前两个台阶的方法数

curr=ppre+pre

### 杨辉三角

dp【i】【j】表示第i行第j个数

$$dp[i][j]=dp[i-1][j-1]+dp[i-1][j]$$

### 打家劫舍

dp【i】表示前i家能偷到的最大金额

$$dp[i]=max(dp[i-2]+nums[i],dp[i-1])$$

### ==完全平方数==

### 零钱兑换



### ==单词拆分==

dp[i]表示到下表i能否被拆分。

枚举0到i-1当中的分割点j

### 最长递增子序列

dp[i]表示以下标i结尾的最长递增子序列

### 乘积最大子数组

maxdp[i]表示以下标i结尾的乘积最大子数组

mindp[i]表示以下标i结尾的乘积最小子数组

根据nums[i]的正负分情况讨论。

```c++
if(nums[i]<0){
                maxdp[i]=max(nums[i]*mindp[i-1],nums[i]);
                mindp[i]=min(nums[i]*maxdp[i-1],nums[i]);
            }
            else {
                maxdp[i]=max(nums[i]*maxdp[i-1],nums[i]);
                mindp[i]=min(nums[i]*mindp[i-1],nums[i]);
            }
```

### 分割等和子集

dp\[i][j]表示前i个数能否凑出j

类似于01背包问题

### 最长有效括号

dp[i]表示以i结尾的最长有效括号。

如果s[i]为右括号，检查s[i-1],如果s[i-1]为左括号，dp

[i]=dp[i-2],如果s[i-1]为右括号，dp[i]=dp[i-1]+2+dp[i-1-dp[i-1]-1]

## 多维动态规划

### 不同路径

dp\[i][j]表示下标i，j位置的路径数

### 最小路径和

dp\[i][j]表示该位置的最小路径和

### ==最长回文子串==

dp\[i][j]表示该子串是否是回文串

### ==最长公共子序列==

dp\[i][j]表示text1前i个字符和text2前j个字符的最长公共子序列

如果text1[i-1]等于text2[j-1]，那么dp\[i][j]=dp\[i-1][j-1]+1;

 反之选择max(dp\[i-1][j],dp\[i][j-1])

### ==编辑距离==

dp\[i][j]表示text1前i个字符和text2前j个字符的编辑距离

如果text1[i-1]等于text2[j-1]，那么dp\[i][j]=min(dp\[i-1][j-1],dp\[i-1][j]+1,dp\[i][j-1]+1);

 反之选择min(dp\[i-1][j]+1,dp\[i][j-1]+1,dp\[i-1][j-1]+1)

## 技巧

### 只出现一次的数字

将所有数异或

### 多数元素

- 随机法
- 排序法
- 哈希表
- 暴力枚举

### 颜色分类

partition

### ==下一个排列==

从右往左找到第一个降序元素，然后继续从右往左找到第一个大于该元素的元素，交换这两个元素之后，将第一个找到的元素后面的部分翻转。

### ==寻找重复数==

指针盘圈